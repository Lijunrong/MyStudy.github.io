排序算法：
1 冒泡排序：两两比较，每一趟比较，将较小者升上去，第一次比较空间为0-（N-1），最后一次比较为0-1,时间复杂度为O(N*N)

核心算法：
int []a = [6,5 8,1,0,11];
int temp = 0;
for(int i =0;i<length-1;i++){  //总共length元素，所以比较length趟
  for (int j = 0;j<length - i -1;j++){   //每一趟比较次数为length -i次
    if（a[j]>a[j+1]）{
       temp = a[j];
       a[j] = a[j+1];
       a[j+1] = temp;
    }
  }
}

经过每一趟比较，把最大值沉底，每趟比较次数L-i-1，因为i从0开始，所以要减去1，当i=0时，比较次数就是L-1; 最好的情况：0次 即序列是有序的，最坏的情况：逆序，次数 n*(n-1)/2;

2 选择排序（O（N*N））：
每趟比较，找到最小的值，然后跟每趟第一个元素交换位置，如：第一趟，比较N个数，找到最小值跟第一个交换位置，第二趟，从剩下的N-1个数找到最小值，并与第二个数交换位置，
第N-1趟时，剩下两个数进行比较，较小的跟第N-1个交换位置：算法位置：
int []a = [6,5,8,1,0,11];
int min = 0;
for(int i=0;i<L;i++){
  min = i;
  for(int j=i+1;j<l;J++){
    if(a[j]<a[min]){
      min = j;
    }
  }
  
  if(min!=i){
    int temp = a[min];
    a[min] = a[i];
    temp = a[min];
  }
}

3 插入排序:就是未排序的数据，在已排序的序列中找到对应位置插入，对应位置：就是第一个比当前元素小的元素位置后面，比如序列 3 5，插入元素4，那么4的位置就在3的后面，5的前面
算法：
for(int i = 0;i<L;i++){
  for(int j= i;j>0;j--){
    if(a[j]<a[j-1]){
       int temp = a[j];
       a[j] = a[j-1];
       temp = a[j];
    }else{
      break;
    }
  }
}

插入排序：
最好的情况，次数是n-1,序列有序，最坏的情况，序列逆序，次数:1+2+3...+n-1 = n*(n-1)/2，平均次数是最差的一半，所以时间复杂度为o(n*n)；



O（N*logN）算法：归并排序，快速排序，堆排序，希尔排序
快速排序：从待排序的序列中任取一个元素作为key，经过一段排序后，把所有小于key的元素放在key的左边，所有大于key的元素放到了右边，将序列分成了两个字表，最后将key值放在分界处的位置上
然后，分别对左右子表进行重复操作，直到每个字表只有一个记录时，排序完成！

void quickSort(int *arr,int begin,int end){
  int low = begin;
  int high = end;
  int key = arr[0];
  if(low>=end) {
    return;
  }
  while(low<high){
    while(low<high&&arr[high]>key){
      high--;
    }
    arr[low] = arr[high];
    while(low<high&&arr[low]<=key){
      low++;
    }
    arr[high] = arr[low];
  }
  arr[i] = key;
  quickSort(arr,begin,i-1);
  quickSort(arr,i+1,end);
}

快速排序的平均时间是：O（n*log2N），最坏的情况：O(N*N)。

归并排序：
总的平均时间复杂度为O(nlogn)
归并排序利用归并思想进行排序，采用分治策略,算法：

void merge_sort(int*data,int start,int end,int*result){
 if(end-start==2){
  if(data[start]>data[end]){ //有两个元素，进行排序
    int temp = data[start];
    data[start] = data[end];
    data[end] = temp;
  }
  return;
 }else if(end-start==1){ //只有一个元素，直接返回
   return;
 }else{ //继续拆分
    merge_sort(data,start,(end-start+1)/2+start,result);
    merge_sort(data,(end-start+1)/2+start+1,end,result);
    merge(data,start,end,result);
 } 
}

void merge(int*data,int start,int end,int*result){
  int left_index = start;
  int left_length = (end-start+1)/2 +1;
  int right_index = start + left_length;
  int result_index = start;
  while(left_index<start+ left_length &&right_index<end+1){
    if(data[left_index]<=data[right_index]){
      result[result_index++] = data[left_index];
    }else{
      result[result_index++] = data[right_index];
    }
  }
  
  while(left_index<start+left_length){
    result[result_index++] = data[left_index++];
  }
  
  while(right_index<end+1){
    result[result_index++] = data[right_index++];
  }
  
}

堆：
堆是一种特殊的完全二叉树：每个根节点都大于等于左右子节点或者根节点小于等于左右子节点，同时根节点的左右子树也是堆，平均时间复杂度O(nLogn)


堆排序步骤：
1 将序列构成一个堆，根据升序或者降序构成大顶堆，或者小顶堆；
2 将堆首元素与堆尾元素交换，使得堆尾元素成为最大值；
3 剩下的元素重新构建大顶堆，然后重新交换堆首元素与堆尾元素，如此反复。

代码:
#include<iostream>
#include<vector>
using namespace std;

//length data的长度，index第一个非叶子结点的索引
void adjust(vector<int>&data,int length,int index){
  int left_child = 2*index +1;
  int right_child = 2*index + 2;
  int max_index = index;
  if(left_child<length&&data[left_child]>data[max_index]){
    max_index = left_child;
  }else if(right_child<length&&data[right_child]>data[max_index]){
    max_index = right_child;
  }
  
  if(max_index!=index){
    swap(data[max_index],data[index]);
    adjust(data,length,max_index);
  }
}

void heapSort(vector<int>&data,int size){

  //构建大顶堆，从最后一个非叶子结点往上构建
  for(int i = size/2-1;i>=0;i--){
    adjust(data,size,i)
  }
  
  for(int i=size-1;i>=1;i--){
    swap(data[0],data[i]);//将最大元素放数组末尾
    adjust(data,i,0);//剩下为排序的重新构建堆
  }
}



希尔排序:
思路：
设置增量（步长），根据增量将序列分组，然后每一个小组进行插入排序，缩小增量，重复造作，直到增量为1了，这时候序列就是有序了

伪代码：
#define STEP 2
void XIER(){
  int insertNum = 0;//用于保存当前插入元素；
  int gap = len/STEP;
  int curIndex = 0;//保存当前索引
  while(gap){
    for(int i = gap;i<len;i++){
      curInex = i;
      insertNum = array[i];
      while(curIndex>=gap&&insertNum<array[cutIndex-gap]){
        array[curIndex] = array[cutIndex - gap];
        curIndex = curIndex - gap;
      }
      array[curIndex] = insertNum;
    }
    gap = gap/2;
  }
}

时间复杂度：O（nlogn）

普利姆算法：利用贪心策略，思路：
顶点集合是V

首先设置S = {1},只要S是V的真子集，就做如下贪心选择：

选取S中的元素i,j属于V-S,且c[i][j]是权值最小的边，那么将顶点j添加到S中，一直到S=V了
#define MAXINT 6
int c[MAXINT][MAXINT] = {}
void Prim(int length){
  int lowcost[MAXINT];
  int closest[MAXINT];
  bool s[MAXINT];
  s[0] = true;
  for(int i=1;i<length;i++){
    lowcost[i] = c[0][i];
    closest[i] = 0;
    s[i] = false;
  }
  
  for(int i=0;i<length-1;i++){
    int min = 100000;
    int j = 1;
    for(int k=1;k<length;k++){
      if(lowcost[k]<min&&!min[k]){
         min = lowcost[k];
         j = k;
      }
    }
    
    s[j] = 0;
    for(int k=1;k<length;k++){
      if(c[j][k]<mincost[k]&&!s[k]){
          mincost[k] = c[j][k];
          closest[k] = j;
      }
    }
  }
}

时间复杂度O(N*N)














