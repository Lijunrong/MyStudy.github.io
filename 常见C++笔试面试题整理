常见C++笔试面试题整理

1，C和C++的区别：

c:面向过程的语言，c++面向对象的语言，面向对象有三个基本特征：封装，继承，多态

封装：隐藏实现的细节，使得代码模块化

继承：派生类去继承子类的数据和方法，拓展已有的模块，实现代码的重用

多态：一个接口，多种实现，派生类去重写基类的虚函数，实现接口的重用。

管理内存不同：c使用malloc/free，c++除了malloc/free,还有new /delect

c++ 支持重载函数，c不支持重载函数，c++存在引用，c不存在引用


2，c++ 指针和引用的区别？
指针：是一个新的变量，保存另一个变量的地址，通过访问变量地址，从而拿到变量的数据

引用：引用其实是变量的别名，还是变量的本身，所以对引用做任何修改，都会应用到原来的变量，也就是原来的变量值也会跟着变化

指针传参：传的是变量的地址的值，所以修改形参的值，不会改变实参的值，也就是值传递

引用传参：传的实际是变量的别名，还是变量本身，所以修改形参，会同时改变实参的值


3 结构体struct和共同体union（联合）的区别

结构体：不同类型的数据组成的一个整体，是自定义类型，每个成员都有自己的地址，是同时存在

联合体：不同类型的变量共占一段相同的内存，所有成员共同占用一段内存，不能同时存在

sizeof(stuct) 得到的是内存对齐后，所有成员的长度总和，sizeof(union) 得到的是内存对齐后，长度最长的变量的长度

4 #define 和 const

#define 定义的常量没有类型，const 定义的常量有类型；

处理阶段不同：#define 定义的常量是在预编译阶段，const定义的常量是在编译阶段

#define 可以定义简单的函数，const 不能定义函数

5 重载，覆盖，重写，三者区别？

重载：函数名字一样，参数和返回值不一样，比如运算符重载

覆盖：派生类覆盖基类函数，基类函数必须是虚函数，用virtual声明为虚函数，函数名相同，参数相同

重写：派生类重写基类函数，基类函数不是虚函数，普通函数，参数可以相同，也可以不同，不用virtual

6 malloc/free，new/delete 有什么区别？
都是动态分配内存函数，区别：

malloc/free，严格指定内存大小，new 不需要

new：为对象分配内存，会调用类的构造函数，delete:调用类的析构函数

7 delete 和 delete[]区别？
delete 只会调用一次析构函数，delete[]调用所有成员的析构函数

new和delete 组合用，new[] 则要用delete[];

8 STL容器有哪些，算法用过哪几个？

分两种容器：1，序列式容器,2，关联式容器

序列式容器：元素可以进行排序，比如vector,list,array,heap,queue,stack

关联式容器：内部维护一个平衡二叉树，关联式容器有：map,set,hashtable,hash_set

9 const知道吗？解释一下其作用
const 修饰的变量是常量，不能修改其值
const 修饰的函数为常函数，不会修改类的数据成员，也不能调用非const成员函数

10 虚函数是怎么实现的?
每一个含有虚函数的类，都有一个虚函数表，虚函数表存放该类所有的虚函数对应的函数指针（函数地址）
派生类会兼容基类的虚函数表。

11 堆和栈的区别？

栈是有系统自动分配内存，并自动释放内存，比较小，存储函数的参数，临时变量
堆：是要手动new 和手动delete掉，比较大，通过new操作的数据就存放在堆上

12 STL中map和set的原理（关联式容器）
Map 和Set底层原理是红黑树

13 #include<file.h> #include "file.h" 的区别

#include<file.h>:从标准库寻找
#include "file.h",从当前路径寻找

14 什么是内存泄露，面对内存泄露和指针越界，有哪些方法？

通过malloc 或者new 申请的内存，没有及时释放，就会造成内存泄露
解决方案，配套着使用，malloc 和free配套使用，new 和delete 配套使用，对指针的使用时注意被赋值的指针是否需要释放，使用的时候记得指针的长度，防止越界。


15 定义和声明的区别？
声明：就是告诉编译器，变量的类型和名字，没有分配空间
定义：就是给变量分配空间，变量可以被声明多次，但只会被分配一次内存

16 C++文件编译与执行的四个阶段

预处理：通过预处理指令来修改源文件内容；
编译：编译成汇编代码
汇编：把汇编代码翻译成目标机器指令
链接：生成可执行程序

17： C++的内存管理：
c++内存本分为：栈，堆，自由存储区，静态存储区，常量区
栈：系统自动分配内存，并自动释放，用于存储函数参数，临时变量；
堆：手动申请内存，手动释放，通过new/delete,通过malloc/free
静态存储区：全局/静态存储区：分别存储全局变量和静态变量
常量区：存储常量


18：构造函数为什么不定义为虚函数，析构函数为什么要定义为虚函数呢？
对象创建时需要知道其类型，而虚函数是在运行时才知道其类型，构造函数在构造对象时，由于对象还未创建成功，所以无法确定对象类型，是基类还是派生类；
虚函数调用需要虚函数表指针，而虚函数表指针存放在对象的内存中，而构造函数调用时，对象还没创建成功，所以不存在虚函数表指针。

析构函数必须声明为虚函数，当析构一个指向派生类的基类时，如果不声明为虚函数，那么只会调用基类的析构函数，而不会调用派生类的析构函数，从而导致内存泄露。

19 深拷贝和浅拷贝的区别：
如果一个类拥有资源，在这个类的对象发生复制的过程，如果资源重新分配了，就是深拷贝，如果资源没有重新分配，就是浅拷贝。

20 





















